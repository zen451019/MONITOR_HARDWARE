<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MODBUS MASTER MONITOR: src/main.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MODBUS MASTER MONITOR<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('main_8cpp.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">main.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Modbus RTU Master Firmware over LoRaWAN (ESP32/TTGO).  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;Arduino.h&gt;</code><br />
<code>#include &lt;SPI.h&gt;</code><br />
<code>#include &lt;hal/hal.h&gt;</code><br />
<code>#include &lt;lmic.h&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;map&gt;</code><br />
<code>#include &lt;ctime&gt;</code><br />
<code>#include &lt;cstring&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &quot;ModbusClientRTU.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:ModbusSensorParam" id="r_ModbusSensorParam"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_modbus_sensor_param.html">ModbusSensorParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the configuration parameters for an individual sensor.  <a href="struct_modbus_sensor_param.html#details">More...</a><br /></td></tr>
<tr class="memitem:ModbusSlaveParam" id="r_ModbusSlaveParam"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_modbus_slave_param.html">ModbusSlaveParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global vector that stores the configuration and state of all discovered Modbus slaves.  <a href="struct_modbus_slave_param.html#details">More...</a><br /></td></tr>
<tr class="memitem:ModbusRequestInfo" id="r_ModbusRequestInfo"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_modbus_request_info.html">ModbusRequestInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context of an in-flight Modbus request.  <a href="struct_modbus_request_info.html#details">More...</a><br /></td></tr>
<tr class="memitem:ResponseFormat" id="r_ResponseFormat"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_response_format.html">ResponseFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intermediate structure to pass data from the Modbus callback to tasks.  <a href="struct_response_format.html#details">More...</a><br /></td></tr>
<tr class="memitem:SensorSchedule" id="r_SensorSchedule"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sensor_schedule.html">SensorSchedule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Planning element for sensor sampling.  <a href="struct_sensor_schedule.html#details">More...</a><br /></td></tr>
<tr class="memitem:EventManagerFormat" id="r_EventManagerFormat"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_event_manager_format.html">EventManagerFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message structure for internal event communication.  <a href="struct_event_manager_format.html#details">More...</a><br /></td></tr>
<tr class="memitem:BitPacker" id="r_BitPacker"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_bit_packer.html">BitPacker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for packing arbitrary bits into a byte stream.  <a href="struct_bit_packer.html#details">More...</a><br /></td></tr>
<tr class="memitem:SensorDataPayload" id="r_SensorDataPayload"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sensor_data_payload.html">SensorDataPayload</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for processed sensor data, ready for aggregation.  <a href="struct_sensor_data_payload.html#details">More...</a><br /></td></tr>
<tr class="memitem:Fragmento" id="r_Fragmento"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_fragmento.html">Fragmento</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary fragment ready for LoRaWAN transmission.  <a href="struct_fragmento.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa7089c01538b339ae745173c117f95b9" id="r_gaa7089c01538b339ae745173c117f95b9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__modbus__discovery.html#gaa7089c01538b339ae745173c117f95b9">RX_PIN</a>&#160;&#160;&#160;13</td></tr>
<tr class="memdesc:gaa7089c01538b339ae745173c117f95b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Utilidades de memoria (memcpy).  <br /></td></tr>
<tr class="memitem:ga3bb17f5daa2b1eaef58c8aa2d989e27e" id="r_ga3bb17f5daa2b1eaef58c8aa2d989e27e"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TX_PIN</b>&#160;&#160;&#160;12</td></tr>
<tr class="memdesc:ga3bb17f5daa2b1eaef58c8aa2d989e27e"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART transmission pin for RS485. <br /></td></tr>
<tr class="memitem:ga7f49ab031357b041f1760f2092028d70" id="r_ga7f49ab031357b041f1760f2092028d70"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_MODBUS_RESPONSE_LENGTH</b>&#160;&#160;&#160;256</td></tr>
<tr class="memdesc:ga7f49ab031357b041f1760f2092028d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum expected length for a Modbus response. <br /></td></tr>
<tr class="memitem:ga0e4d980a0884c2ea678ba5f5e8b0f716" id="r_ga0e4d980a0884c2ea678ba5f5e8b0f716"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_SENSOR_PAYLOAD</b>&#160;&#160;&#160;128</td></tr>
<tr class="memdesc:ga0e4d980a0884c2ea678ba5f5e8b0f716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of an individual sensor payload. <br /></td></tr>
<tr class="memitem:ga9568f3936a82ae3248a8e777c2689bcd" id="r_ga9568f3936a82ae3248a8e777c2689bcd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__data__format.html#ga9568f3936a82ae3248a8e777c2689bcd">AGGREGATION_INTERVAL_MS</a>&#160;&#160;&#160;6100</td></tr>
<tr class="memdesc:ga9568f3936a82ae3248a8e777c2689bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregation interval (ms).  <br /></td></tr>
<tr class="memitem:ga104199bd4a032dd152c9f397a4dcf2b3" id="r_ga104199bd4a032dd152c9f397a4dcf2b3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__data__format.html#ga104199bd4a032dd152c9f397a4dcf2b3">AGGREGATION_INTERVAL_MS</a>&#160;&#160;&#160;6100</td></tr>
<tr class="memdesc:ga104199bd4a032dd152c9f397a4dcf2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregation interval (ms).  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga46a07d73c79d4b8999372b819403da58" id="r_ga46a07d73c79d4b8999372b819403da58"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__modbus__discovery.html#ga46a07d73c79d4b8999372b819403da58">DiscoveryOrder</a> { <a class="el" href="group__group__modbus__discovery.html#ga46a07d73c79d4b8999372b819403da58a1e1800af67b81d987bb00060533d5915">DISCOVERY_GET_COUNT</a> = 1
, <a class="el" href="group__group__modbus__discovery.html#ga46a07d73c79d4b8999372b819403da58a7a182e1d066bf8f45714fb1d7f0549e1">DISCOVERY_GET_DATA_OFFSET</a> = 255
, <a class="el" href="group__group__modbus__discovery.html#ga46a07d73c79d4b8999372b819403da58aea7e33cbb3a664bdb9a7e871353aa21e">DISCOVERY_READ_SENSOR_PARAM</a> = 8
 }</td></tr>
<tr class="memdesc:ga46a07d73c79d4b8999372b819403da58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special commands used during the sensor discovery phase.  <a href="group__group__modbus__discovery.html#ga46a07d73c79d4b8999372b819403da58">More...</a><br /></td></tr>
<tr class="memitem:gae10b07f2d0feb103db7fe4cfd192e5af" id="r_gae10b07f2d0feb103db7fe4cfd192e5af"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__modbus__discovery.html#gae10b07f2d0feb103db7fe4cfd192e5af">RequestType</a> { <a class="el" href="group__group__modbus__discovery.html#gae10b07f2d0feb103db7fe4cfd192e5afacc059c796c5ae2d0205ad730768999b7">REQUEST_UNKNOWN</a>
, <a class="el" href="group__group__modbus__discovery.html#gae10b07f2d0feb103db7fe4cfd192e5afa3232d13dce2d61800581b3b1c0b1611d">REQUEST_DISCOVERY</a>
, <a class="el" href="group__group__modbus__discovery.html#gae10b07f2d0feb103db7fe4cfd192e5afa5ade4fdadde8b1ec2bc10668653efa7b">REQUEST_SAMPLING</a>
 }</td></tr>
<tr class="memdesc:gae10b07f2d0feb103db7fe4cfd192e5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classification of the purpose of a Modbus request.  <a href="group__group__modbus__discovery.html#gae10b07f2d0feb103db7fe4cfd192e5af">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2b6bd4e110caa560464cc252a7dc787f" id="r_ga2b6bd4e110caa560464cc252a7dc787f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__modbus__discovery.html#ga2b6bd4e110caa560464cc252a7dc787f">addRequest</a> (uint32_t token, uint8_t slaveId, uint8_t sensorId, uint8_t functionCode, <a class="el" href="group__group__modbus__discovery.html#gae10b07f2d0feb103db7fe4cfd192e5af">RequestType</a> type)</td></tr>
<tr class="memdesc:ga2b6bd4e110caa560464cc252a7dc787f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a new request in the circular buffer.  <br /></td></tr>
<tr class="memitem:ga5e9b156cfc98d9c060bfd23770ed3590" id="r_ga5e9b156cfc98d9c060bfd23770ed3590"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_modbus_request_info.html">ModbusRequestInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__modbus__discovery.html#ga5e9b156cfc98d9c060bfd23770ed3590">findRequestByToken</a> (uint32_t token)</td></tr>
<tr class="memdesc:ga5e9b156cfc98d9c060bfd23770ed3590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a pending request by its token.  <br /></td></tr>
<tr class="memitem:gaec0c4943af093ad42d2d099ceeadb98c" id="r_gaec0c4943af093ad42d2d099ceeadb98c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__modbus__discovery.html#gaec0c4943af093ad42d2d099ceeadb98c">initScheduler</a> ()</td></tr>
<tr class="memdesc:gaec0c4943af093ad42d2d099ceeadb98c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes or updates the scheduling list (Scheduler).  <br /></td></tr>
<tr class="memitem:gae13ecbdf143b216f696e59a9b7edb141" id="r_gae13ecbdf143b216f696e59a9b7edb141"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__modbus__discovery.html#gae13ecbdf143b216f696e59a9b7edb141">handleData</a> (ModbusMessage response, uint32_t token)</td></tr>
<tr class="memdesc:gae13ecbdf143b216f696e59a9b7edb141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback executed upon receiving valid Modbus data.  <br /></td></tr>
<tr class="memitem:ga944f73ca5a3437229e84a3317d2a1634" id="r_ga944f73ca5a3437229e84a3317d2a1634"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__modbus__discovery.html#ga944f73ca5a3437229e84a3317d2a1634">handleError</a> (Error error, uint32_t token)</td></tr>
<tr class="memdesc:ga944f73ca5a3437229e84a3317d2a1634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback executed when a Modbus error occurs.  <br /></td></tr>
<tr class="memitem:ga86b51577aeff55acd47a303f408339ea" id="r_ga86b51577aeff55acd47a303f408339ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__modbus__discovery.html#ga86b51577aeff55acd47a303f408339ea">discoverDeviceSensors</a> (uint8_t deviceId)</td></tr>
<tr class="memdesc:ga86b51577aeff55acd47a303f408339ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the discovery process for a specific device.  <br /></td></tr>
<tr class="memitem:gab0e674715eff7261b0ae3a35fe239be4" id="r_gab0e674715eff7261b0ae3a35fe239be4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__modbus__discovery.html#gab0e674715eff7261b0ae3a35fe239be4">initialDiscoveryTask</a> (void *pvParameters)</td></tr>
<tr class="memdesc:gab0e674715eff7261b0ae3a35fe239be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">One-shot task for the initial discovery of sensors.  <br /></td></tr>
<tr class="memitem:gafe37cc62bf5e1b7be5d4b906edac7444" id="r_gafe37cc62bf5e1b7be5d4b906edac7444"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__modbus__discovery.html#gafe37cc62bf5e1b7be5d4b906edac7444">DataRequestScheduler</a> (void *pvParameters)</td></tr>
<tr class="memdesc:gafe37cc62bf5e1b7be5d4b906edac7444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main task of the Scheduler.  <br /></td></tr>
<tr class="memitem:ga320e20ed89286bb200de38e3c0d74cde" id="r_ga320e20ed89286bb200de38e3c0d74cde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__modbus__discovery.html#ga320e20ed89286bb200de38e3c0d74cde">getSensorParams</a> (uint8_t slaveId, uint8_t sensorID, uint16_t &amp;startAddr, uint16_t &amp;numRegs)</td></tr>
<tr class="memdesc:ga320e20ed89286bb200de38e3c0d74cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the configuration parameters of a specific sensor.  <br /></td></tr>
<tr class="memitem:ga8a81627d82ccf43aef00a4023d2d6e55" id="r_ga8a81627d82ccf43aef00a4023d2d6e55"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__modbus__discovery.html#ga8a81627d82ccf43aef00a4023d2d6e55">getRegistersPerChannel</a> (uint8_t slaveId, uint8_t sensorID)</td></tr>
<tr class="memdesc:ga8a81627d82ccf43aef00a4023d2d6e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the number of registers per channel for a sensor.  <br /></td></tr>
<tr class="memitem:gacd852b44946c142cee5128d699ead65a" id="r_gacd852b44946c142cee5128d699ead65a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__modbus__discovery.html#gacd852b44946c142cee5128d699ead65a">parseAndStoreDiscoveryResponse</a> (const <a class="el" href="struct_response_format.html">ResponseFormat</a> &amp;response, uint8_t slaveId)</td></tr>
<tr class="memdesc:gacd852b44946c142cee5128d699ead65a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the discovery response and updates the slave list.  <br /></td></tr>
<tr class="memitem:gac0c8aeee251d675a0300a1e3be22e9fe" id="r_gac0c8aeee251d675a0300a1e3be22e9fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__modbus__discovery.html#gac0c8aeee251d675a0300a1e3be22e9fe">EventManager</a> (void *pvParameters)</td></tr>
<tr class="memdesc:gac0c8aeee251d675a0300a1e3be22e9fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event Manager task.  <br /></td></tr>
<tr class="memitem:gaa63af787bc417df8c3fb79de881c76db" id="r_gaa63af787bc417df8c3fb79de881c76db"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__data__format.html#gaa63af787bc417df8c3fb79de881c76db">formatAndEnqueueSensorData</a> (const <a class="el" href="struct_response_format.html">ResponseFormat</a> &amp;response, const <a class="el" href="struct_modbus_request_info.html">ModbusRequestInfo</a> &amp;request, std::vector&lt; uint8_t &gt; &amp;values)</td></tr>
<tr class="memdesc:gaa63af787bc417df8c3fb79de881c76db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts and formats data from a sampling Modbus response.  <br /></td></tr>
<tr class="memitem:ga6e1aae328466a42dd05ab781287cff08" id="r_ga6e1aae328466a42dd05ab781287cff08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__data__format.html#ga6e1aae328466a42dd05ab781287cff08">DataFormatter</a> (void *pvParameters)</td></tr>
<tr class="memdesc:ga6e1aae328466a42dd05ab781287cff08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data Formatter task.  <br /></td></tr>
<tr class="memitem:a59da9aa00714b51865d1964e7dc98864" id="r_a59da9aa00714b51865d1964e7dc98864"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59da9aa00714b51865d1964e7dc98864">DataPrinterTask</a> (void *pvParameters)</td></tr>
<tr class="memdesc:a59da9aa00714b51865d1964e7dc98864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tarea temporal para imprimir los payloads de datos formateados.  <br /></td></tr>
<tr class="memitem:gadb9c946e2e438c9965ca61090ab6d7db" id="r_gadb9c946e2e438c9965ca61090ab6d7db"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__data__format.html#gadb9c946e2e438c9965ca61090ab6d7db">construirPayloadUnificado</a> (uint8_t id_mensaje, const std::vector&lt; <a class="el" href="struct_sensor_data_payload.html">SensorDataPayload</a> &gt; &amp;collectedPayloads)</td></tr>
<tr class="memdesc:gadb9c946e2e438c9965ca61090ab6d7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a unified payload from a collection of sensor data.  <br /></td></tr>
<tr class="memitem:gad00e5aa32f425c7cf5b551edbe4e2018" id="r_gad00e5aa32f425c7cf5b551edbe4e2018"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>os_getArtEui</b> (u1_t *buf)</td></tr>
<tr class="memdesc:gad00e5aa32f425c7cf5b551edbe4e2018"><td class="mdescLeft">&#160;</td><td class="mdescRight">LMIC configuration functions (placeholders). <br /></td></tr>
<tr class="memitem:a59f8459c9afe001b9d082b88f24bbc06" id="r_a59f8459c9afe001b9d082b88f24bbc06"><td class="memItemLeft" align="right" valign="top"><a id="a59f8459c9afe001b9d082b88f24bbc06" name="a59f8459c9afe001b9d082b88f24bbc06"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>os_getDevEui</b> (u1_t *buf)</td></tr>
<tr class="memitem:a876d512ca10c7f577c86f5dc1894bc49" id="r_a876d512ca10c7f577c86f5dc1894bc49"><td class="memItemLeft" align="right" valign="top"><a id="a876d512ca10c7f577c86f5dc1894bc49" name="a876d512ca10c7f577c86f5dc1894bc49"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>os_getDevKey</b> (u1_t *buf)</td></tr>
<tr class="memitem:gaaead836f5e0f65f5906b7ce269e92436" id="r_gaaead836f5e0f65f5906b7ce269e92436"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lorawan.html#gaaead836f5e0f65f5906b7ce269e92436">onEvent</a> (ev_t ev)</td></tr>
<tr class="memdesc:gaaead836f5e0f65f5906b7ce269e92436"><td class="mdescLeft">&#160;</td><td class="mdescRight">LMIC/LoRaWAN event callback.  <br /></td></tr>
<tr class="memitem:ga0fa8265a8114d3d0ea5632aec720d8ec" id="r_ga0fa8265a8114d3d0ea5632aec720d8ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lorawan.html#ga0fa8265a8114d3d0ea5632aec720d8ec">initLoRa</a> ()</td></tr>
<tr class="memdesc:ga0fa8265a8114d3d0ea5632aec720d8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the LMIC stack and configures LoRaWAN (ABP, US915).  <br /></td></tr>
<tr class="memitem:ga85ff6eb902587d8e8c4ba34f146725ef" id="r_ga85ff6eb902587d8e8c4ba34f146725ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lorawan.html#ga85ff6eb902587d8e8c4ba34f146725ef">tareaLoRa</a> (void *pvParameters)</td></tr>
<tr class="memdesc:ga85ff6eb902587d8e8c4ba34f146725ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task dedicated to sending data via LoRaWAN.  <br /></td></tr>
<tr class="memitem:gad52a9758ff13752b83fdb6fc1a4bc61c" id="r_gad52a9758ff13752b83fdb6fc1a4bc61c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lorawan.html#gad52a9758ff13752b83fdb6fc1a4bc61c">tareaRunLoop</a> (void *pvParameters)</td></tr>
<tr class="memdesc:gad52a9758ff13752b83fdb6fc1a4bc61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">LMIC runloop task.  <br /></td></tr>
<tr class="memitem:ga163106434b453ca6396d3f14c38ef282" id="r_ga163106434b453ca6396d3f14c38ef282"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__data__format.html#ga163106434b453ca6396d3f14c38ef282">DataAggregatorTask</a> (void *pvParameters)</td></tr>
<tr class="memdesc:ga163106434b453ca6396d3f14c38ef282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proactive task that collects and packages sensor data at a fixed rate.  <br /></td></tr>
<tr class="memitem:a4fc01d736fe50cf5b977f755b675f11d" id="r_a4fc01d736fe50cf5b977f755b675f11d"><td class="memItemLeft" align="right" valign="top"><a id="a4fc01d736fe50cf5b977f755b675f11d" name="a4fc01d736fe50cf5b977f755b675f11d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setup</b> ()</td></tr>
<tr class="memitem:afe461d27b9c48d5921c00d521181f12f" id="r_afe461d27b9c48d5921c00d521181f12f"><td class="memItemLeft" align="right" valign="top"><a id="afe461d27b9c48d5921c00d521181f12f" name="afe461d27b9c48d5921c00d521181f12f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loop</b> ()</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gafba4fdd67a5d79a0cdbf6d3652ccb5b5" id="r_gafba4fdd67a5d79a0cdbf6d3652ccb5b5"><td class="memItemLeft" align="right" valign="top">
ModbusClientRTU&#160;</td><td class="memItemRight" valign="bottom"><b>MB</b></td></tr>
<tr class="memdesc:gafba4fdd67a5d79a0cdbf6d3652ccb5b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global instance of the Modbus RTU client. <br /></td></tr>
<tr class="memitem:aad08baa918db3ca57bf4eb72aa49cf79" id="r_aad08baa918db3ca57bf4eb72aa49cf79"><td class="memItemLeft" align="right" valign="top"><a id="aad08baa918db3ca57bf4eb72aa49cf79" name="aad08baa918db3ca57bf4eb72aa49cf79"></a>
std::vector&lt; <a class="el" href="struct_modbus_slave_param.html">ModbusSlaveParam</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>slaveList</b></td></tr>
<tr class="memitem:a5c3074121496d3d76bd1b55dcdf20e2b" id="r_a5c3074121496d3d76bd1b55dcdf20e2b"><td class="memItemLeft" align="right" valign="top"><a id="a5c3074121496d3d76bd1b55dcdf20e2b" name="a5c3074121496d3d76bd1b55dcdf20e2b"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_REQUESTS</b> = 16</td></tr>
<tr class="memdesc:a5c3074121496d3d76bd1b55dcdf20e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of the pending requests buffer. <br /></td></tr>
<tr class="memitem:aefd820f21d3f2f61fd1290584df797d5" id="r_aefd820f21d3f2f61fd1290584df797d5"><td class="memItemLeft" align="right" valign="top"><a id="aefd820f21d3f2f61fd1290584df797d5" name="aefd820f21d3f2f61fd1290584df797d5"></a>
<a class="el" href="struct_modbus_request_info.html">ModbusRequestInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><b>requestBuffer</b> [<a class="el" href="#a5c3074121496d3d76bd1b55dcdf20e2b">MAX_REQUESTS</a>]</td></tr>
<tr class="memdesc:aefd820f21d3f2f61fd1290584df797d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Circular buffer for requests. <br /></td></tr>
<tr class="memitem:af465f9750fea3bcc15cec3e6523b1f87" id="r_af465f9750fea3bcc15cec3e6523b1f87"><td class="memItemLeft" align="right" valign="top"><a id="af465f9750fea3bcc15cec3e6523b1f87" name="af465f9750fea3bcc15cec3e6523b1f87"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>requestHead</b> = 0</td></tr>
<tr class="memdesc:af465f9750fea3bcc15cec3e6523b1f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write index of the circular buffer. <br /></td></tr>
<tr class="memitem:gaa744737f20ae412448361b8aa57d8efb" id="r_gaa744737f20ae412448361b8aa57d8efb"><td class="memItemLeft" align="right" valign="top">
QueueHandle_t&#160;</td><td class="memItemRight" valign="bottom"><b>queueRespuestas</b></td></tr>
<tr class="memdesc:gaa744737f20ae412448361b8aa57d8efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue for received Modbus responses. <br /></td></tr>
<tr class="memitem:gab204d0e5b1e10f59187110e07d7782b4" id="r_gab204d0e5b1e10f59187110e07d7782b4"><td class="memItemLeft" align="right" valign="top">
QueueHandle_t&#160;</td><td class="memItemRight" valign="bottom"><b>queueEventos_Peripheral</b></td></tr>
<tr class="memdesc:gab204d0e5b1e10f59187110e07d7782b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event queues to the EventManager (peripherals and scheduler). <br /></td></tr>
<tr class="memitem:aaeca6af4d09f770f0da02c452009fd42" id="r_aaeca6af4d09f770f0da02c452009fd42"><td class="memItemLeft" align="right" valign="top"><a id="aaeca6af4d09f770f0da02c452009fd42" name="aaeca6af4d09f770f0da02c452009fd42"></a>
QueueHandle_t&#160;</td><td class="memItemRight" valign="bottom"><b>queueEventos_Scheduler</b></td></tr>
<tr class="memitem:aa0cb4638b4d20baf82b458055d12dc7b" id="r_aa0cb4638b4d20baf82b458055d12dc7b"><td class="memItemLeft" align="right" valign="top"><a id="aa0cb4638b4d20baf82b458055d12dc7b" name="aa0cb4638b4d20baf82b458055d12dc7b"></a>
QueueHandle_t&#160;</td><td class="memItemRight" valign="bottom"><b>queueFragmentos</b></td></tr>
<tr class="memdesc:aa0cb4638b4d20baf82b458055d12dc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue for binary LoRa messages. <br /></td></tr>
<tr class="memitem:a9500a5f5069fb86a01a7c3b63c0029b8" id="r_a9500a5f5069fb86a01a7c3b63c0029b8"><td class="memItemLeft" align="right" valign="top"><a id="a9500a5f5069fb86a01a7c3b63c0029b8" name="a9500a5f5069fb86a01a7c3b63c0029b8"></a>
SemaphoreHandle_t&#160;</td><td class="memItemRight" valign="bottom"><b>semaforoEnvioCompleto</b></td></tr>
<tr class="memdesc:a9500a5f5069fb86a01a7c3b63c0029b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semaphore to synchronize the end of a sending cycle. <br /></td></tr>
<tr class="memitem:a3008cc0b8c65d61cdad0c1e10f3c9293" id="r_a3008cc0b8c65d61cdad0c1e10f3c9293"><td class="memItemLeft" align="right" valign="top"><a id="a3008cc0b8c65d61cdad0c1e10f3c9293" name="a3008cc0b8c65d61cdad0c1e10f3c9293"></a>
std::vector&lt; <a class="el" href="struct_sensor_schedule.html">SensorSchedule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>scheduleList</b></td></tr>
<tr class="memdesc:a3008cc0b8c65d61cdad0c1e10f3c9293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Master scheduling list. <br /></td></tr>
<tr class="memitem:abadaff9f6b3275804b5985d7acb91a6d" id="r_abadaff9f6b3275804b5985d7acb91a6d"><td class="memItemLeft" align="right" valign="top"><a id="abadaff9f6b3275804b5985d7acb91a6d" name="abadaff9f6b3275804b5985d7acb91a6d"></a>
SemaphoreHandle_t&#160;</td><td class="memItemRight" valign="bottom"><b>schedulerMutex</b></td></tr>
<tr class="memdesc:abadaff9f6b3275804b5985d7acb91a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex to protect concurrent access to scheduleList;. <br /></td></tr>
<tr class="memitem:a5e78a612252d23106755e7351cb84b0d" id="r_a5e78a612252d23106755e7351cb84b0d"><td class="memItemLeft" align="right" valign="top"><a id="a5e78a612252d23106755e7351cb84b0d" name="a5e78a612252d23106755e7351cb84b0d"></a>
std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>dispositivosAConsultar</b> = {1, 2, 3}</td></tr>
<tr class="memdesc:a5e78a612252d23106755e7351cb84b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predefined list of Modbus IDs to scan at startup. <br /></td></tr>
<tr class="memitem:a885cd17b8d6f1b323dcddb0be64fe46f" id="r_a885cd17b8d6f1b323dcddb0be64fe46f"><td class="memItemLeft" align="right" valign="top"><a id="a885cd17b8d6f1b323dcddb0be64fe46f" name="a885cd17b8d6f1b323dcddb0be64fe46f"></a>
QueueHandle_t&#160;</td><td class="memItemRight" valign="bottom"><b>queueSensorDataPayload</b></td></tr>
<tr class="memdesc:a885cd17b8d6f1b323dcddb0be64fe46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue for processed sensor payloads. <br /></td></tr>
<tr class="memitem:ab6be6b2affdf508141e4e063f6568d6a" id="r_ab6be6b2affdf508141e4e063f6568d6a"><td class="memItemLeft" align="right" valign="top"><a id="ab6be6b2affdf508141e4e063f6568d6a" name="ab6be6b2affdf508141e4e063f6568d6a"></a>
const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>SENSOR_ID_BATERIA</b> = 0</td></tr>
<tr class="memdesc:ab6be6b2affdf508141e4e063f6568d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigned to Bit 0 of the Activate Byte. <br /></td></tr>
<tr class="memitem:ab7c3d8b5ac5185f0d70c950ff7b0c12d" id="r_ab7c3d8b5ac5185f0d70c950ff7b0c12d"><td class="memItemLeft" align="right" valign="top"><a id="ab7c3d8b5ac5185f0d70c950ff7b0c12d" name="ab7c3d8b5ac5185f0d70c950ff7b0c12d"></a>
const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>SENSOR_ID_VOLTAJE</b> = 1</td></tr>
<tr class="memdesc:ab7c3d8b5ac5185f0d70c950ff7b0c12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigned to Bit 1 of the Activate Byte. <br /></td></tr>
<tr class="memitem:ac827a3ecae0ff95ccaab990487ea5bab" id="r_ac827a3ecae0ff95ccaab990487ea5bab"><td class="memItemLeft" align="right" valign="top"><a id="ac827a3ecae0ff95ccaab990487ea5bab" name="ac827a3ecae0ff95ccaab990487ea5bab"></a>
const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>SENSOR_ID_CORRIENTE</b> = 2</td></tr>
<tr class="memdesc:ac827a3ecae0ff95ccaab990487ea5bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigned to Bit 2 of the Activate Byte. <br /></td></tr>
<tr class="memitem:aaf3662a2e779ed1e86a0983bf9064ef8" id="r_aaf3662a2e779ed1e86a0983bf9064ef8"><td class="memItemLeft" align="right" valign="top"><a id="aaf3662a2e779ed1e86a0983bf9064ef8" name="aaf3662a2e779ed1e86a0983bf9064ef8"></a>
const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>SENSOR_ID_EXT_START</b> = 3</td></tr>
<tr class="memdesc:aaf3662a2e779ed1e86a0983bf9064ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of IDs for external sensors (Bits 3-7). <br /></td></tr>
<tr class="memitem:a1bb6bd711fc58ba9c7709aa2eccd1a8d" id="r_a1bb6bd711fc58ba9c7709aa2eccd1a8d"><td class="memItemLeft" align="right" valign="top"><a id="a1bb6bd711fc58ba9c7709aa2eccd1a8d" name="a1bb6bd711fc58ba9c7709aa2eccd1a8d"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_SENSORES_EXTERNOS</b> = 5</td></tr>
<tr class="memdesc:a1bb6bd711fc58ba9c7709aa2eccd1a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of remaining available bits (3 to 7). <br /></td></tr>
<tr class="memitem:ga323b816c981b219d0c28b9c5b49c1961" id="r_ga323b816c981b219d0c28b9c5b49c1961"><td class="memItemLeft" align="right" valign="top">static u1_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lorawan.html#ga323b816c981b219d0c28b9c5b49c1961">NWKSKEY</a> [16]</td></tr>
<tr class="memdesc:ga323b816c981b219d0c28b9c5b49c1961"><td class="mdescLeft">&#160;</td><td class="mdescRight">ABP keys and device address (DEMO).  <br /></td></tr>
<tr class="memitem:a3341f4c8411e8fd968488d6acac102db" id="r_a3341f4c8411e8fd968488d6acac102db"><td class="memItemLeft" align="right" valign="top">static u1_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3341f4c8411e8fd968488d6acac102db">APPSKEY</a> [16]</td></tr>
<tr class="memitem:a3adc8d701d1073e18973bb0483afe1d0" id="r_a3adc8d701d1073e18973bb0483afe1d0"><td class="memItemLeft" align="right" valign="top"><a id="a3adc8d701d1073e18973bb0483afe1d0" name="a3adc8d701d1073e18973bb0483afe1d0"></a>
static const u4_t&#160;</td><td class="memItemRight" valign="bottom"><b>DEVADDR</b> = 0x260C691F</td></tr>
<tr class="memitem:ga82b2c57ed09941537a4e8bf84b35a5eb" id="r_ga82b2c57ed09941537a4e8bf84b35a5eb"><td class="memItemLeft" align="right" valign="top">const lmic_pinmap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lorawan.html#ga82b2c57ed09941537a4e8bf84b35a5eb">lmic_pins</a></td></tr>
<tr class="memdesc:ga82b2c57ed09941537a4e8bf84b35a5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pin map for the SX127x radio of the TTGO LoRa32.  <br /></td></tr>
<tr class="memitem:aa8df913af10e7848bb8ca04df5a001c7" id="r_aa8df913af10e7848bb8ca04df5a001c7"><td class="memItemLeft" align="right" valign="top"><a id="aa8df913af10e7848bb8ca04df5a001c7" name="aa8df913af10e7848bb8ca04df5a001c7"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>LORA_PAYLOAD_MAX</b> = 220</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Modbus RTU Master Firmware over LoRaWAN (ESP32/TTGO). </p>
<p>This system manages RS485 communication with multiple slaves, schedules periodic readings, formats the data, and transmits it via LoRaWAN. </p><dl class="section date"><dt>Date</dt><dd>2025-12-02 </dd></dl>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a59da9aa00714b51865d1964e7dc98864" name="a59da9aa00714b51865d1964e7dc98864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59da9aa00714b51865d1964e7dc98864">&#9670;&#160;</a></span>DataPrinterTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataPrinterTask </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>pvParameters</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tarea temporal para imprimir los payloads de datos formateados. </p>
<p>Simula el consumidor final (que será la tarea LoRa) para propósitos de depuración. </p>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="a3341f4c8411e8fd968488d6acac102db" name="a3341f4c8411e8fd968488d6acac102db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3341f4c8411e8fd968488d6acac102db">&#9670;&#160;</a></span>APPSKEY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">u1_t APPSKEY[16]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    0x42, 0x8F, 0x67, 0xFA, 0xD7, 0xD7, 0x4A, 0x85,</div>
<div class="line">    0x3C, 0x10, 0x80, 0x5F, 0x10, 0x1A, 0x0E, 0x14</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>src</b></li><li class="navelem"><a href="main_8cpp.html">main.cpp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
